package euler

object ProjectEuler {
  /*
   * Even Fibonacci numbers
   *
   * Each new term in the Fibonacci sequence is generated by adding the previous
   * two terms. By starting with 1 and 2, the first 10 terms will be:
   *
   * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
   *
   * By considering the terms in the Fibonacci sequence whose values do not
   * exceed four million, find the sum of the even-valued terms.
   */

  def problem2(): Int = {
    def fib(n:Int) :Int =  n match {
      case 0 | 1 => n
      case _ => fib(n-1) + fib(n-2)
    }

    def acceptable(n :Int) = {
      n < 4000000 && n % 2 == 0
    }

    def nfibs(n :Int) = {
      Range(1,n).toList.map(fib)
    }

    nfibs(40).filter((x) => acceptable(x)).reduce((x:Int, xs:Int) => x + xs)
  }

  /*
   * Largest palindrome product
   *
   * A palindromic number reads the same both ways. The largest palindrome made
   * from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
   *
   * Find the largest palindrome made from the product of two 3-digit numbers.
   *
   */

  def problem4(): Int = {
    def isPalindrome(n :Int) :Boolean = {
      val numAsCharList = n.toString.toList
      recursion(numAsCharList)
    }

    def dropHeads[A](list :List[A]) :List[A] = {
      list.tail.dropRight(1)
    }

    // Looks nasty, I blame sucking at Scala, maybe pattern matching would work?
    def recursion(list :List[Char]) :Boolean = {
      if(list.isEmpty)
        false
      else if (list.length == 1)
        true
      else if(list.head == list.last && list.length == 2)
        true
      else if (list.head == list.last)
        recursion(dropHeads(list))
      else
        false
    }

    // These two steps could be optimized but it runs in decent time already (< 1 second on my macbook pr0)
    val numbersToTest = Range(100,999).toList.reverse
    numbersToTest.map((x) => numbersToTest.map((y) => x * y)).flatten.filter(isPalindrome).max

  }

  /*
   * Special Pythagorean triplet
   *
   * A Pythagorean triplet is a set of three natural numbers, a < b < c, for
   * which, a^2 + b^2 = c^2
   *
   * For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
   *
   * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
   * Find the product abc.
   */
  def problem9(): Int = {
    def isPytagoreanTriplet(a :Int, b :Int, c :Int) :Boolean = {
      if(a > b)
        false
      else if(b > c)
        false
      else
        a * a + b * b == c * c
    }

    def isSpecial(a :Int, b:Int, c:Int) :Boolean = {
      a + b + c == 1000 && isPytagoreanTriplet(a,b,c)
    }

    // First create a list of tuples like (a,b) where a < b
    val tuples = List.range(1,500).map((x) => List.range(1,500).map((y) => (x,y))).flatten.filter((t) => t._1 < t._2)

    // Then calculate c for each tuple created above and test if it's special
    // Take the head of the list generated this way. We know there is only one result, the head.
    val abc = tuples.map((t) => (t._1, t._2, Math.sqrt((t._1 * t._1) + (t._2 * t._2)).toInt)).filter((x) => isSpecial(x._1, x._2, x._3)).head

    // return the product of the created tuple
    abc._1 * abc._2 * abc._3
  }


  /*
   * Maximum path sum I
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *      3
   *     7 4
   *    2 4 6
   *   8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom of the given triangle with 15
   * rows:
   */
  def problem18(triangle: List[List[Int]]): Int = {

    // Start from the bottom row of the triangle

    def recursion(list :List[List[Int]]) :List[List[Int]] = {
      if(list.length == 1)
        list
      else {

        // Take the row above the current row, and create a new row
        // The new row should have each element mapped as the maximum of it + it's two lower neighbours

        val recalculatedRow = calculateRow(list.head, list.tail.head)
        recursion(recalculatedRow :: list.tail.tail)
      }
    }

    def calculateRow(upperList :List[Int], lowerList :List[Int]) :List[Int] = {

      // For loop wannabe, I needed the i to acces spesific points of the list
      List.range(0, lowerList.length).map((i) => lowerList(i) + Math.max(upperList(i), upperList(i+1)))
    }

    recursion(triangle.reverse).flatten.head

   }

  /*
   * Maximum path sum II
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *    3
   *   7 4
   *  2 4 6
   * 8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom in the given triangle with
   * one-hundred rows.
   *
   * NOTE: This is a much more difficult version of Problem 18. It is not
   * possible to try every route to solve this problem, as there are 2^99
   * altogether! If you could check one trillion (10^12) routes every second it
   * would take over twenty billion years to check them all. There is an
   * efficient algorithm to solve it. ;o)
   */
  def problem67(triangle: List[List[Int]]): Int = problem18(triangle) // This felt good :D
}
